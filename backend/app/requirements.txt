index.html
fastapi
uvicorn[standard]
aiohttp
playwright==1.35.0
beautifulsoup4
jinja2
python-multipart
# scraper.py
import asyncio
from playwright.async_api import async_playwright
from bs4 import BeautifulSoup
import re
async def fetch_match_stats(url: str, timeout=45000):
    """Return parsed statistics dict from an AiScore match page."""
    async with async_playwright() as p:
        browser = await p.chromium.launch(args=["--no-sandbox"], headless=True)
        page = await browser.new_page()
        await page.goto(url, wait_until="networkidle", timeout=timeout)
        # small wait for dynamic elements
        await asyncio.sleep(1.0)
        html = await page.content()
        await browser.close()

    return parse_aiscore_html(html)

def parse_aiscore_html(html: str):
    soup = BeautifulSoup(html, "lxml")

    # defaults
    minute = 0
    score_home = 0
    score_away = 0

    # try to find minute
    time_el = soup.select_one(".tm, .time, .minute, .match-time")
    if time_el:
        txt = time_el.get_text(strip=True)
        m = re.search(r"(\d+)'", txt)
        if m:
            minute = int(m.group(1))

    # try score
    score_el = soup.select_one(".score, .match-score, .vs")
    if score_el:
        s = score_el.get_text(strip=True)
        m = re.search(r"(\d+)\s*[:\-]\s*(\d+)", s)
        if m:
            score_home = int(m.group(1))
            score_away = int(m.group(2))

    def get_stat_by_keywords(keywords):
        for kw in keywords:
            el = soup.find(text=re.compile(kw, re.I))
            if el:
                parent = el.find_parent()
                if parent:
                    return parent.get_text(" ", strip=True)
        return None

    attacks_text = get_stat_by_keywords(["Attack", "Attacks", "Atak"])
    danger_text = get_stat_by_keywords(["Danger", "Dangerous", "Tehlikeli"])
    shots_text = get_stat_by_keywords(["Shot on target", "ƒ∞sabetli ≈üut", "Shots on target"])
    red_text = get_stat_by_keywords(["Red card", "Kƒ±rmƒ±zƒ± kart"])
    poss_text = get_stat_by_keywords(["Possession", "Topla oynama", "%"])

    def parse_pair(text):
        if not text:
            return (0,0)
        m = re.search(r"(\d+)\s*[-:]\s*(\d+)", text)
        if m:
            return (int(m.group(1)), int(m.group(2)))
        nums = re.findall(r"\d+", text)
        if len(nums) >= 2:
            return (int(nums[0]), int(nums[1]))
        return (0,0)

    attacks = parse_pair(attacks_text)
    danger = parse_pair(danger_text)
    shots = parse_pair(shots_text)

    reds = (0,0)
    if red_text:
        nums = re.findall(r"\d+", red_text)
        if len(nums) >= 2:
            reds = (int(nums[0]), int(nums[1]))
        elif len(nums) == 1:
            reds = (int(nums[0]), 0)

    poss = (50,50)
    if poss_text:
        m = re.findall(r"(\d+)%", poss_text)
        if len(m) >= 2:
            poss = (int(m[0]), int(m[1]))

    return {
        "minute": minute,
        "score_home": score_home,
        "score_away": score_away,
        "attacks_home": attacks[0],
        "attacks_away": attacks[1],
        "danger_home": danger[0],
        "danger_away": danger[1],
        "shots_home": shots[0],
        "shots_away": shots[1],
        "reds_home": reds[0],
        "reds_away": reds[1],
        "pos_home": poss[0],
        "pos_away": poss[1],
        "raw_ok": True
    }# model.py
def compute_model_score(stats: dict) -> float:
    total_goals = stats.get("score_home",0) + stats.get("score_away",0)
    attacks_total = stats.get("attacks_home",0) + stats.get("attacks_away",0)
    danger_total = stats.get("danger_home",0) + stats.get("danger_away",0)
    shots_total = stats.get("shots_home",0) + stats.get("shots_away",0)
    reds_total = stats.get("reds_home",0) + stats.get("reds_away",0)
    pos_diff = abs(stats.get("pos_home",50) - stats.get("pos_away",50))

    score = (total_goals * 0.6
             + (attacks_total / 200.0) * 1.5
             + (danger_total / 100.0) * 2.0
             + (shots_total / 10.0) * 1.0
             - reds_total * 1.5
             + (stats.get("pos_home",50) - stats.get("pos_away",50)) / 20.0)
    return score

def prob_from_score(score: float):
    base = 30 + score * 10
    if base < 5: base = 5
    if base > 95: base = 95
    return round(base, 0)

def predict_2_5(stats: dict):
    score = compute_model_score(stats)
    prob = prob_from_score(score)
    pred = "√úST ‚öΩ" if prob >= 55 else "ALT üõë"
    return {"score": score, "prob2_5": prob, "prediction": pred}

def predict_last10(stats: dict):
    p25 = predict_2_5(stats)["prob2_5"]
    minute = stats.get("minute",0)
    poss_diff = abs(stats.get("pos_home",50) - stats.get("pos_away",50))
    if minute >= 80:
        prob = min(98, p25 + 10 + (poss_diff/2))
    else:
        prob = p25
    pred = "Son10: Gol OLUR" if (minute >= 80 and prob >= 50) else "Son10: Gol OLMAYABƒ∞Lƒ∞R"
    return {"prob_last10": round(prob,0), "prediction_last10": pred}# main.py
import asyncio
from fastapi import FastAPI, BackgroundTasks
from fastapi.responses import StreamingResponse
import json
from .scraper import fetch_match_stats
from .model import predict_2_5, predict_last10
import time

app = FastAPI(title="Live Predict Panel Backend")

TRACKED = {}  # url -> {alias, stats, last_update}
POLL_INTERVAL = 10  # seconds

@app.get("/")
async def root():
    return {"message": "Live Predict Panel Backend OK"}

@app.post("/track")
async def track_match(payload: dict, background_tasks: BackgroundTasks):
    url = payload.get("match_url")
    alias = payload.get("alias", url)
    if not url:
        return {"error": "match_url required"}
    if url in TRACKED:
        return {"status": "already_tracking", "match": alias}
    TRACKED[url] = {"alias": alias, "stats": None, "last_update": 0}
    background_tasks.add_task(poll_match, url)
    return {"status": "tracking_started", "match": alias}

async def poll_match(url):
    while url in TRACKED:
        try:
            stats = await fetch_match_stats(url)
            TRACKED[url]["stats"] = stats
            TRACKED[url]["last_update"] = time.time()
        except Exception as e:
            TRACKED[url]["stats"] = {"error": str(e)}
        await asyncio.sleep(POLL_INTERVAL)

@app.post("/untrack")
async def untrack(payload: dict):
    url = payload.get("match_url")
    if url and url in TRACKED:
        del TRACKED[url]
        return {"status": "stopped"}
    return {"error": "not tracked"}

@app.get("/matches")
async def list_matches():
    return [{"url": k, "alias": v["alias"], "last": v["last_update"]} for k,v in TRACKED.items()]

@app.get("/stream")
async def stream():
    async def event_generator():
        while True:
            payload = []
            for url, item in TRACKED.items():
                stats = item.get("stats")
                if stats:
                    p25 = predict_2_5(stats)
                    p10 = predict_last10(stats)
                    payload.append({
                        "url": url,
                        "alias": item.get("alias"),
                        "stats": stats,
                        "predict_2_5": p25,
                        "predict_last10": p10
                    })
            yield f"data: {json.dumps(payload)}\n\n"
            await asyncio.sleep(2)
    return StreamingResponse(event_generator(), media_type="text/event-stream")FROM python:3.11-slim

RUN apt-get update && apt-get install -y wget gnupg ca-certificates \
    libnss3 libatk-bridge2.0-0 libatk1.0-0 libcups2 libxcomposite1 libxrandr2 libxdamage1 libx11-xcb1 libgtk-3-0 libgbm-dev \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY app/requirements.txt /app/requirements.txt
RUN pip install --no-cache-dir -r /app/requirements.txt

# Install Playwright browsers (will be run during build)
RUN playwright install --with-deps

COPY app /app/app
ENV PYTHONPATH=/app

EXPOSE 8000
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]#!/bin/bash
playwright install --with-deps
uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Canlƒ± Tahmin Paneli</title>
<link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="app">
    <header><h1>Canlƒ± Tahmin Paneli</h1></header>
    <section class="controls">
      <input id="matchUrl" placeholder="AiScore ma√ß URL'si (virg√ºlle birden √ßok ekleyebilirsin)"/>
      <input id="alias" placeholder="Takma isim (opsiyonel)"/>
      <button id="addBtn">Ekle & Takip Et</button>
      <button id="clearBtn">T√ºm√ºn√º Durdur</button>
    </section>

    <section id="matches" class="matches">Hen√ºz ma√ß yok. Ma√ß URL ekleyin.</section>
  </div>

<script>
const API_BASE = ''; // deploy sonrasƒ± backend url koy. localhost test i√ßin http://localhost:8000

document.getElementById('addBtn').onclick = async () => {
  const urls = document.getElementById('matchUrl').value.split(',').map(s=>s.trim()).filter(Boolean);
  const alias = document.getElementById('alias').value.trim();
  if (urls.length===0) return alert('Ma√ß URL girin');
  for (const u of urls) {
    await fetch(API_BASE + '/track', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({match_url:u, alias: alias || u})});
  }
  document.getElementById('matchUrl').value='';
  document.getElementById('alias').value='';
};

document.getElementById('clearBtn').onclick = async () => {
  const res = await fetch(API_BASE + '/matches');
  const data = await res.json();
  for (const m of data) {
    await fetch(API_BASE + '/untrack', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({match_url: m.url})});
  }
};

const matchesDiv = document.getElementById('matches');

const es = new EventSource(API_BASE + '/stream');

es.onmessage = (e) => {
  const payload = JSON.parse(e.data);
  renderMatches(payload);
};

function renderMatches(list) {
  matchesDiv.innerHTML = '';
  if (!list || list.length === 0) {
    matchesDiv.innerHTML = '<p>Hen√ºz ma√ß yok. Ma√ß URL ekleyin.</p>';
    return;
  }
  list.forEach(m => {
    const st = m.stats;
    const p = m.predict_2_5;
    const p10 = m.predict_last10;
    const el = document.createElement('div');
    el.className = 'match';
    el.innerHTML = `
      <div class="header"><strong>${m.alias}</strong><span>${st.minute}' - ${st.score_home}:${st.score_away}</span></div>
      <div class="grid">
        <div>Atak: ${st.attacks_home} - ${st.attacks_away}</div>
        <div>Tehlikeli: ${st.danger_home} - ${st.danger_away}</div>
        <div>ƒ∞sabetli ≈ûut: ${st.shots_home} - ${st.shots_away}</div>
        <div>Kƒ±rmƒ±zƒ±: ${st.reds_home} - ${st.reds_away}</div>
        <div>Poss: ${st.pos_home}% - ${st.pos_away}%</div>
      </div>
      <div class="predictions">
        <div class="box"><strong>2.5:</strong> ${p.prediction} (${p.prob2_5}%)</div>
        <div class="box"><strong>Son10:</strong> ${p10.prediction_last10} (${p10.prob_last10}%)</div>
      </div>
    `;
    matchesDiv.appendChild(el);
  });
}
</script>
</body>
</html>:root{
  --bg:#0f1720; --card:#111827; --muted:#9CA3AF; --accent:#06b6d4;
  --green:#10b981; --red:#ef4444;
}
body{font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:#e6eef6;margin:0;padding:16px}
.app{max-width:980px;margin:0 auto}
header h1{font-size:20px;margin:6px 0 12px}
.controls{display:flex;gap:8px;margin-bottom:12px}
.controls input{flex:1;padding:10px;border-radius:8px;border:1px solid #263041;background:#071226;color:#e6eef6}
.controls button{padding:10px 12px;border-radius:8px;border:none;background:var(--accent);color:#062022;cursor:pointer}
.matches .match{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:12px;border-radius:10px;margin-bottom:10px;border:1px solid rgba(255,255,255,0.03)}
.header{display:flex;justify-content:space-between;margin-bottom:8px}
.grid{display:grid;grid-template-columns:repeat(3,1fr);gap:6px;font-size:13px;color:var(--muted)}
.predictions{display:flex;gap:8px;margin-top:10px}
.box{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px}version: '3.8'
services:
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    volumes:
      - ./backend/app:/app/app
    environment:
      - PYTHONUNBUFFERED=1
    restart: unless-stoppedLive Predict Panel - Deploy Guide

1) Build locally:
   docker-compose up --build

2) For Render deployment:
   - Push repo to GitHub.
   - On Render create Web Service -> Connect repo.
   - Build command: docker build -t live-predict-panel .
   - Start command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --workers 1
   - Ensure Render runs 'playwright install --with-deps' during build (Dockerfile already contains it).

3) After deploy:
   - Open frontend (serve static files via simple static host or open index.html and set API_BASE to your backend URL).
